create extension pgcrypto;

create table users (
	user_id int4 generated by default as identity (start with 1 increment by 1) primary key,
	firstname character varying(24) not null,
	lastname character varying(24) not null,
	username character varying(32) not null,
	password character varying(60) not null,
	balance decimal(16, 2) default 0,
	deleted_at timestamp with time zone default null,
	created_at timestamp with time zone default current_timestamp
);

create unique index username_idx on users (lower(username));
create index fullname_idx on users ((firstname || ' ' || lastname));

create or replace function bi_users_fn() returns trigger language plpgsql as $$
	begin
		if (
			select new.firstname ~ '(?=.{2,24}$)(?![a-z])^[A-Z]{1}(?!.*[''.]{2})[a-z'']+[a-z]$'
		) then
			if (
				select new.lastname ~ '(?=.{2,24}$)(?![a-z])^[A-Z]{1}(?!.*[''.]{2})[a-z'']+[a-z]$'
			) then
				if (
					select new.username ~ '^(?=.{3,32}$)(?![_.0-9])(?!.*[_.]{2})[a-zA-Z_]+([^._])([0-9]{0,})$'
				) then
					if (
						select new.password ~ '(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#\$%\^&\*]).{6,}'
					) then
						new.password := crypt(new.password, gen_salt('bf'));
						return new;
					else
						raise exception 'The password does not match the pattern';
						return null;
					end if;
				else
					raise exception 'The username does not match the pattern';
					return null;
				end if;
			else
				raise exception 'The lastname does not match the pattern';
				return null;
			end if;
		else
			raise exception 'The firstname does not match the pattern';
			return null;
		end if;

	end;
$$;

create table deposits (
	deposit_id int4 generated by default as identity (start with 1 increment by 1) primary key,
	account_id int4 not null references users (user_id),
	operator_id int4 not null references users (user_id),
	amount decimal(16, 2) default 0,
	deposit_time timestamp with time zone default current_timestamp
);

create trigger bi_users before insert on users for each row execute procedure bi_users_fn();
-- drop trigger bi_users on users;

create table teachers (
	teacher_id int4 generated by default as identity (start with 1 increment by 1) primary key,
	user_id int4 not null references users (user_id)
);

create table permissions (
	permission_id int4 generated by default as identity (start with 1 increment by 1) primary key,
	action int2 not null,
	user_id int4 not null references users (user_id)
);

create table branches (
	branch_id int4 generated by default as identity (start with 1 increment by 1) primary key,
	name character varying(64) not null
);

create table rooms (
	room_id int4 generated by default as identity (start with 1 increment by 1) primary key,
	room_name character varying(32) not null,
	branch_id int4 not null references branches(branch_id)
);

create table courses (
	course_id int4 generated by default as identity (start with 1 increment by 1) primary key,
	name character varying(64) not null
);

create table groups (
	group_id int4 generated by default as identity (start with 1 increment by 1) primary key,
	price decimal(16, 2) not null,
	lessons int2 not null,
	completed_lessons int2 default 0,
	completed_at timestamp with time zone default null,
	user_id int4 not null references users (user_id),
	course_id int4 not null references courses(course_id),
	branch_id int4 not null references branches(branch_id),
	room_id int4 not null references rooms (room_id)
);

create table pariticipants (
	pariticipant_id int4 generated by default as identity (start with 1 increment by 1) primary key,
	discount int2 default 0,
	raise int2 default 0,
	role int2 default 1,
	initial_lesson int2 default 0,
	group_id int4 not null references groups(group_id),
	user_id int4 not null references users (user_id)
);

create or replace function bi_pariticipants_fn() returns trigger language plpgsql as $$
	begin
		
		new.initial_lesson = (
			select completed_lessons from groups
			where group_id = new.group_id
		);

		return new;

	end;
$$;

create trigger bi_pariticipants before insert on pariticipants for each row execute procedure bi_pariticipants_fn();

create table lessons (
	lesson_id int4 generated by default as identity (start with 1 increment by 1) primary key,
	started_at timestamp with time zone default current_timestamp,
	finished_at timestamp with time zone default null,
	group_id int4 not null references groups(group_id)
);

create or replace function au_lessons_fn() returns trigger language plpgsql as $$
	begin

		update groups set completed_lessons = (
			select count(lesson_id) from lessons
			where group_id = new.group_id and finished_at is not null
		)
		where group_id = new.group_id;

		return new;

	end;
$$;

create trigger au_lessons after update on lessons for each row execute procedure au_lessons_fn();
